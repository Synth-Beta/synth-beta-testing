import { supabase } from '@/integrations/supabase/client';
import type { Event } from '@/types/concertSearch';

export class DCEventSeeder {
  private static readonly JAMBASE_API_KEY = import.meta.env.VITE_JAMBASE_API_KEY;
  
  private static validateApiKey(): boolean {
    if (!this.JAMBASE_API_KEY) {
      console.error('‚ùå VITE_JAMBASE_API_KEY is not set. Please set it in your .env.local file.');
      return false;
    }
    return true;
  }
  private static readonly JAMBASE_BASE_URL = 'https://api.jambase.com';

  // Fetch upcoming events in Washington, DC from JamBase
  static async fetchDCEvents(): Promise<Event[]> {
    try {
      // Validate API key before making any requests
      if (!this.validateApiKey()) {
        console.error('‚ùå Cannot fetch DC events: JAMBASE_API_KEY is not set');
        return [];
      }

      console.log('üéµ Starting to fetch DC events from JamBase...');
      
      const events: Event[] = [];
      let page = 1;
      const eventsPerPage = 50; // JamBase API limit
      
      // Get today's date in YYYY-MM-DD format
      const today = new Date();
      const todayString = today.toISOString().split('T')[0];
      
      // Get date 6 months from now for upper limit
      const sixMonthsFromNow = new Date();
      sixMonthsFromNow.setMonth(sixMonthsFromNow.getMonth() + 6);
      const endDateString = sixMonthsFromNow.toISOString().split('T')[0];

      while (events.length < 100 && page <= 3) { // Max 3 pages to avoid rate limiting
        const url = new URL(`${this.JAMBASE_BASE_URL}/events`);
        url.searchParams.append('api_key', this.JAMBASE_API_KEY!);
        url.searchParams.append('geoCity', 'Washington');
        url.searchParams.append('geoState', 'DC');
        url.searchParams.append('eventDateFrom', todayString);
        url.searchParams.append('eventDateTo', endDateString);
        url.searchParams.append('limit', eventsPerPage.toString());
        url.searchParams.append('page', page.toString());

        console.log(`üì° Fetching page ${page} from JamBase...`);
        console.log(`üîó URL: ${url.toString()}`);

        const response = await fetch(url.toString());
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error(`‚ùå JamBase API error (page ${page}):`, response.status, errorText);
          break;
        }

        const data = await response.json();
        const pageEvents = data.events || [];
        
        console.log(`‚úÖ Found ${pageEvents.length} events on page ${page}`);

        if (pageEvents.length === 0) {
          console.log('üì≠ No more events found, stopping pagination');
          break;
        }

        // Convert JamBase events to our format
        const convertedEvents = pageEvents.map((jambaseEvent: any) => this.convertJamBaseEvent(jambaseEvent));
        events.push(...convertedEvents);

        page++;
        
        // Add delay to avoid rate limiting
        if (page <= 3) {
          console.log('‚è≥ Waiting 1 second to avoid rate limiting...');
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }

      console.log(`üéâ Total events fetched: ${events.length}`);
      return events.slice(0, 100); // Ensure we only return 100 events max
      
    } catch (error) {
      console.error('üí• Error fetching DC events:', error);
      throw error;
    }
  }

  // Convert JamBase event to our Event format
  private static convertJamBaseEvent(jambaseEvent: any): Event {
    return {
      id: '', // Will be generated by Supabase
      jambase_event_id: jambaseEvent.id,
      title: jambaseEvent.title || `${jambaseEvent.artist?.name || 'Unknown Artist'} Live`,
      artist_name: jambaseEvent.artist?.name || 'Unknown Artist',
      artist_id: jambaseEvent.artist?.id,
      venue_name: jambaseEvent.venue?.name || 'Unknown Venue',
      venue_id: jambaseEvent.venue?.id,
      event_date: jambaseEvent.dateTime || new Date().toISOString(),
      doors_time: jambaseEvent.doors,
      description: jambaseEvent.description || `Live performance by ${jambaseEvent.artist?.name || 'Unknown Artist'} at ${jambaseEvent.venue?.name || 'Unknown Venue'} in Washington, DC`,
      genres: jambaseEvent.artist?.genres || [],
      venue_address: jambaseEvent.venue?.address,
      venue_city: jambaseEvent.venue?.city || 'Washington',
      venue_state: jambaseEvent.venue?.state || 'DC',
      venue_zip: jambaseEvent.venue?.zipCode,
      latitude: jambaseEvent.venue?.latitude,
      longitude: jambaseEvent.venue?.longitude,
      ticket_available: jambaseEvent.ticketing?.available || false,
      price_range: jambaseEvent.ticketing?.priceRange,
      ticket_urls: jambaseEvent.ticketing?.urls || [],
      setlist: jambaseEvent.setlist,
      tour_name: jambaseEvent.tour,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      // Legacy fields
      location: `Washington, DC`,
      event_name: jambaseEvent.title || `${jambaseEvent.artist?.name || 'Unknown Artist'} Live`,
      event_time: jambaseEvent.dateTime ? jambaseEvent.dateTime.split('T')[1] : null,
      url: jambaseEvent.url || '',
    };
  }

  // Save events to Supabase
  static async saveEventsToSupabase(events: Event[]): Promise<number> {
    try {
      console.log('üíæ Starting to save events to Supabase...');
      
      let savedCount = 0;
      const batchSize = 10; // Process in smaller batches to avoid timeouts
      
      for (let i = 0; i < events.length; i += batchSize) {
        const batch = events.slice(i, i + batchSize);
        console.log(`üìù Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(events.length / batchSize)} (${batch.length} events)...`);
        
        try {
          // Filter out events that already exist
          const newEvents = [];
          for (const event of batch) {
            if (event.jambase_event_id) {
              const { data: existing } = await supabase
                .from('jambase_events')
                .select('id')
                .eq('jambase_event_id', event.jambase_event_id)
                .single();
              
              if (!existing) {
                newEvents.push(event);
              } else {
                console.log(`‚è≠Ô∏è  Skipping existing event: ${event.title}`);
              }
            } else {
              newEvents.push(event);
            }
          }

          if (newEvents.length > 0) {
            const { data, error } = await supabase
              .from('jambase_events')
              .insert(newEvents)
              .select('id, title');

            if (error) {
              console.error('‚ùå Error saving batch:', error);
              continue; // Continue with next batch
            }

            savedCount += data?.length || 0;
            console.log(`‚úÖ Saved ${data?.length || 0} new events in this batch`);
            
            // Log some event titles for verification
            if (data && data.length > 0) {
              console.log(`üìã Sample events saved: ${data.slice(0, 3).map(e => e.title).join(', ')}${data.length > 3 ? '...' : ''}`);
            }
          } else {
            console.log('‚è≠Ô∏è  No new events in this batch (all already exist)');
          }

        } catch (batchError) {
          console.error(`‚ùå Error processing batch ${Math.floor(i / batchSize) + 1}:`, batchError);
          continue; // Continue with next batch
        }

        // Add delay between batches
        if (i + batchSize < events.length) {
          console.log('‚è≥ Waiting 500ms before next batch...');
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      }

      console.log(`üéâ Successfully saved ${savedCount} new events to Supabase!`);
      return savedCount;
      
    } catch (error) {
      console.error('üí• Error saving events to Supabase:', error);
      throw error;
    }
  }

  // Main seeding function
  static async seedDCEvents(): Promise<{ fetched: number; saved: number }> {
    try {
      console.log('üöÄ Starting DC Events Seeding Process...');
      console.log('üìç Location: Washington, DC');
      console.log('üéØ Target: 100 upcoming events');
      
      // Step 1: Fetch events from JamBase
      const events = await this.fetchDCEvents();
      console.log(`üìä Fetched ${events.length} events from JamBase`);
      
      if (events.length === 0) {
        console.log('‚ùå No events found to seed');
        return { fetched: 0, saved: 0 };
      }
      
      // Step 2: Save to Supabase
      const savedCount = await this.saveEventsToSupabase(events);
      
      console.log('‚ú® DC Events Seeding Complete!');
      console.log(`üìà Results: ${events.length} fetched, ${savedCount} saved`);
      
      return { fetched: events.length, saved: savedCount };
      
    } catch (error) {
      console.error('üí• DC Events Seeding Failed:', error);
      throw error;
    }
  }
}

// Export for use in components or manual execution
export const seedDCEvents = () => DCEventSeeder.seedDCEvents();
