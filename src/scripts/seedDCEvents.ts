import { supabase } from '@/integrations/supabase/client';
import type { Event } from '@/types/concertSearch';

export class DCEventSeeder {
  private static readonly JAMBASE_API_KEY = import.meta.env.VITE_JAMBASE_API_KEY;
  
  private static validateApiKey(): boolean {
    if (!this.JAMBASE_API_KEY) {
      console.error('‚ùå VITE_JAMBASE_API_KEY is not set. Please set it in your .env.local file.');
      return false;
    }
    return true;
  }
  private static readonly JAMBASE_BASE_URL = 'https://api.jambase.com';

  // DISABLED: Frontend no longer has direct Jambase API access
  // Use backend sync service instead
  static async fetchDCEvents(): Promise<Event[]> {
    console.warn('‚ö†Ô∏è  Jambase API access removed from frontend. Use backend sync service instead.');
        return [];
  }

  // Convert JamBase event to our Event format
  private static convertJamBaseEvent(jambaseEvent: any): Event {
    return {
      id: '', // Will be generated by Supabase
      jambase_event_id: jambaseEvent.id,
      title: jambaseEvent.title || `${jambaseEvent.artist?.name || 'Unknown Artist'} Live`,
      artist_name: jambaseEvent.artist?.name || 'Unknown Artist',
      artist_id: jambaseEvent.artist?.id,
      venue_name: jambaseEvent.venue?.name || 'Unknown Venue',
      venue_id: jambaseEvent.venue?.id,
      event_date: jambaseEvent.dateTime || new Date().toISOString(),
      doors_time: jambaseEvent.doors,
      description: jambaseEvent.description || `Live performance by ${jambaseEvent.artist?.name || 'Unknown Artist'} at ${jambaseEvent.venue?.name || 'Unknown Venue'} in Washington, DC`,
      genres: jambaseEvent.artist?.genres || [],
      venue_address: jambaseEvent.venue?.address,
      venue_city: jambaseEvent.venue?.city || 'Washington',
      venue_state: jambaseEvent.venue?.state || 'DC',
      venue_zip: jambaseEvent.venue?.zipCode,
      latitude: jambaseEvent.venue?.latitude,
      longitude: jambaseEvent.venue?.longitude,
      ticket_available: jambaseEvent.ticketing?.available || false,
      price_range: jambaseEvent.ticketing?.priceRange,
      ticket_urls: jambaseEvent.ticketing?.urls || [],
      setlist: jambaseEvent.setlist,
      tour_name: jambaseEvent.tour,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      // Legacy fields
      location: `Washington, DC`,
      event_name: jambaseEvent.title || `${jambaseEvent.artist?.name || 'Unknown Artist'} Live`,
      event_time: jambaseEvent.dateTime ? jambaseEvent.dateTime.split('T')[1] : null,
      url: jambaseEvent.url || '',
    };
  }

  // Save events to Supabase
  static async saveEventsToSupabase(events: Event[]): Promise<number> {
    try {
      console.log('üíæ Starting to save events to Supabase...');
      
      let savedCount = 0;
      const batchSize = 10; // Process in smaller batches to avoid timeouts
      
      for (let i = 0; i < events.length; i += batchSize) {
        const batch = events.slice(i, i + batchSize);
        console.log(`üìù Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(events.length / batchSize)} (${batch.length} events)...`);
        
        try {
          // Filter out events that already exist
          const newEvents = [];
          for (const event of batch) {
            if (event.jambase_event_id) {
              const { data: existing } = await supabase
                .from('jambase_events')
                .select('id')
                .eq('jambase_event_id', event.jambase_event_id)
                .single();
              
              if (!existing) {
                newEvents.push(event);
              } else {
                console.log(`‚è≠Ô∏è  Skipping existing event: ${event.title}`);
              }
            } else {
              newEvents.push(event);
            }
          }

          if (newEvents.length > 0) {
            const { data, error } = await supabase
              .from('jambase_events')
              .insert(newEvents)
              .select('id, title');

            if (error) {
              console.error('‚ùå Error saving batch:', error);
              continue; // Continue with next batch
            }

            savedCount += data?.length || 0;
            console.log(`‚úÖ Saved ${data?.length || 0} new events in this batch`);
            
            // Log some event titles for verification
            if (data && data.length > 0) {
              console.log(`üìã Sample events saved: ${data.slice(0, 3).map(e => e.title).join(', ')}${data.length > 3 ? '...' : ''}`);
            }
          } else {
            console.log('‚è≠Ô∏è  No new events in this batch (all already exist)');
          }

        } catch (batchError) {
          console.error(`‚ùå Error processing batch ${Math.floor(i / batchSize) + 1}:`, batchError);
          continue; // Continue with next batch
        }

        // Add delay between batches
        if (i + batchSize < events.length) {
          console.log('‚è≥ Waiting 500ms before next batch...');
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      }

      console.log(`üéâ Successfully saved ${savedCount} new events to Supabase!`);
      return savedCount;
      
    } catch (error) {
      console.error('üí• Error saving events to Supabase:', error);
      throw error;
    }
  }

  // Main seeding function
  static async seedDCEvents(): Promise<{ fetched: number; saved: number }> {
    try {
      console.log('üöÄ Starting DC Events Seeding Process...');
      console.log('üìç Location: Washington, DC');
      console.log('üéØ Target: 100 upcoming events');
      
      // Step 1: Fetch events from JamBase
      const events = await this.fetchDCEvents();
      console.log(`üìä Fetched ${events.length} events from JamBase`);
      
      if (events.length === 0) {
        console.log('‚ùå No events found to seed');
        return { fetched: 0, saved: 0 };
      }
      
      // Step 2: Save to Supabase
      const savedCount = await this.saveEventsToSupabase(events);
      
      console.log('‚ú® DC Events Seeding Complete!');
      console.log(`üìà Results: ${events.length} fetched, ${savedCount} saved`);
      
      return { fetched: events.length, saved: savedCount };
      
    } catch (error) {
      console.error('üí• DC Events Seeding Failed:', error);
      throw error;
    }
  }
}

// Export for use in components or manual execution
export const seedDCEvents = () => DCEventSeeder.seedDCEvents();
