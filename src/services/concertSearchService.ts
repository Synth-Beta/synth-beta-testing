import { supabase } from '@/integrations/supabase/client';
import type { 
  Event, 
  EventSearchParams, 
  EventSearchResult, 
  Concert, 
  JamBaseEvent,
  SearchParams,
  SearchResponse,
  ConcertStats
} from '@/types/concertSearch';

const JAMBASE_API_KEY = import.meta.env.VITE_JAMBASE_API_KEY || 'e7ed3a9b-e73a-446e-b7c6-a96d1c53a030';
const JAMBASE_BASE_URL = 'https://www.jambase.com/jb-api/v1';

class ConcertSearchService {
  // Check Supabase for existing event
  async checkExistingEvent(params: EventSearchParams): Promise<Event | null> {
    try {
      const { data, error } = await supabase
        .from('jambase_events')
        .select('*')
        .ilike('artist_name', `%${params.artist}%`)
        .ilike('venue_name', `%${params.venue}%`)
        .eq('event_date', params.date)
        .limit(1)
        .single();

      if (error && error.code !== 'PGRST116') {
        console.error('Supabase error:', error);
        return null;
      }
      return data || null;
    } catch (error) {
      console.error('Error checking existing event:', error);
      return null;
    }
  }

  // Search JamBase if no event in Supabase
  async searchJamBase(params: EventSearchParams): Promise<Event> {
    const url = new URL(`${JAMBASE_BASE_URL}/events`);
    url.searchParams.append('apikey', JAMBASE_API_KEY);
    url.searchParams.append('num', '50');
    url.searchParams.append('page', '0');
    url.searchParams.append('o', 'json');
    if (params.artist) url.searchParams.append('artist', params.artist);
    if (params.venue) url.searchParams.append('venue', params.venue);
    if (params.date) {
      url.searchParams.append('eventDateFrom', params.date);
      url.searchParams.append('eventDateTo', params.date);
    }

    console.log('JamBase API URL:', url.toString());

    const res = await fetch(url.toString());
    if (!res.ok) {
      const errorText = await res.text();
      console.error('JamBase API Error Response:', errorText);
      throw new Error(`JamBase API error: ${res.status} ${res.statusText} - ${errorText}`);
    }
    
    const json = await res.json();
    console.log('JamBase API Response:', json);
    
    // Handle JSON-LD format response
    let events: any[] = [];
    
    if (Array.isArray(json)) {
      events = json;
    } else if (json['@graph'] && Array.isArray(json['@graph'])) {
      events = json['@graph'];
    } else if (json.events && Array.isArray(json.events)) {
      events = json.events;
    }

    const event = events[0];

    if (!event) {
      throw new Error('No event found on JamBase');
    }

    // Handle JSON-LD format
    const eventName = event.name || event.title || 'Untitled Event';
    const identifier = event.identifier || event.id || '';
    const startDate = event.startDate || event.dateTime || new Date().toISOString();
    
    // Extract performer information (JSON-LD format)
    let artistName = '';
    let artistId = '';
    let genres: string[] = [];
    
    if (event.performer && Array.isArray(event.performer)) {
      const headliner = event.performer.find((p: any) => p['x-performanceRank'] === 1) || event.performer[0];
      if (headliner) {
        artistName = headliner.name || '';
        artistId = headliner.identifier || '';
        genres = headliner.genre || [];
      }
    } else if (event.artist) {
      artistName = event.artist.name || '';
      artistId = event.artist.id || '';
      genres = event.artist.genres || [];
    }
    
    // Extract venue information
    const venue = event.location || event.venue || {};
    const venueName = venue.name || 'Unknown Venue';
    const venueId = venue.identifier || venue.id || '';
    const venueAddress = venue.address?.streetAddress || '';
    const venueCity = venue.address?.addressLocality || '';
    const venueState = venue.address?.addressRegion?.alternateName || '';
    const venueZip = venue.address?.postalCode || '';
    const latitude = venue.geo?.latitude || null;
    const longitude = venue.geo?.longitude || null;
    
    // Extract offers/ticketing information
    const offers = event.offers || [];
    const primaryOffer = offers.find((o: any) => o.category === 'ticketingLinkPrimary') || offers[0];
    const ticketAvailable = offers.length > 0;
    const ticketUrl = primaryOffer?.url || '';

    return {
      id: '', // Will be generated by Supabase
      jambase_event_id: identifier,
      title: eventName,
      artist_name: artistName,
      artist_id: artistId,
      venue_name: venueName,
      venue_id: venueId,
      event_date: startDate,
      doors_time: event.doorTime || null,
      description: event.description || `Live performance by ${artistName}`,
      genres: genres,
      venue_address: venueAddress,
      venue_city: venueCity,
      venue_state: venueState,
      venue_zip: venueZip,
      latitude: latitude,
      longitude: longitude,
      ticket_available: ticketAvailable,
      price_range: primaryOffer?.priceSpecification?.price || null,
      ticket_urls: ticketUrl ? [ticketUrl] : [],
      setlist: null,
      tour_name: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      // Legacy fields for backward compatibility
      location: venueCity && venueState 
        ? `${venueCity}, ${venueState}`.trim()
        : '',
      event_name: eventName,
      event_time: startDate.split('T')[1] || null,
      url: event.url || ticketUrl || '',
    };
  }

  // Insert event into Supabase
  async insertEvent(event: Event): Promise<Event> {
    const { data, error } = await supabase
      .from('jambase_events')
      .insert([event])
      .select()
      .single();

    if (error) throw new Error(`Supabase insert failed: ${error.message}`);
    return data!;
  }

  // Link event to user
  async linkEventToUser(eventId: string, userId: string) {
    const { error } = await supabase
      .from('user_jambase_events')
      .insert({ jambase_event_id: eventId, user_id: userId });
    if (error) throw new Error(`Supabase user_event link failed: ${error.message}`);
  }

  // Main search function
  async searchEvent(params: EventSearchParams, userId: string): Promise<EventSearchResult> {
    let event = await this.checkExistingEvent(params);
    let isNew = false;

    if (!event) {
      event = await this.searchJamBase(params);
      const inserted = await this.insertEvent(event);
      event = inserted;
      isNew = true;
    }

    await this.linkEventToUser(event.id, userId);

    return { event, isNewEvent: isNew };
  }

  // Search artists on JamBase (for autocomplete)
  async searchJamBaseArtists(artistName: string): Promise<any[]> {
    const searchUrl = new URL(`${JAMBASE_BASE_URL}/artists`);
    searchUrl.searchParams.append('apikey', JAMBASE_API_KEY);
    searchUrl.searchParams.append('artist', artistName);
    searchUrl.searchParams.append('num', '10');
    searchUrl.searchParams.append('page', '0');
    searchUrl.searchParams.append('o', 'json');

    try {
      console.log('JamBase Artists API URL:', searchUrl.toString());
      const response = await fetch(searchUrl.toString());
      if (!response.ok) {
        const errorText = await response.text();
        console.error('JamBase Artists API Error Response:', errorText);
        throw new Error(`JamBase API error: ${response.status} ${response.statusText} - ${errorText}`);
      }
      const data = await response.json();
      console.log('JamBase Artists API Response:', data);
      return data.artists || [];
    } catch (error) {
      console.error('JamBase Artists API Error:', error);
      throw new Error(`Failed to search JamBase artists: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Search venues on JamBase (for autocomplete)
  async searchJamBaseVenues(venueName: string): Promise<any[]> {
    const searchUrl = new URL(`${JAMBASE_BASE_URL}/venues`);
    searchUrl.searchParams.append('apikey', JAMBASE_API_KEY);
    searchUrl.searchParams.append('venue', venueName);
    searchUrl.searchParams.append('num', '10');
    searchUrl.searchParams.append('page', '0');
    searchUrl.searchParams.append('o', 'json');

    try {
      console.log('JamBase Venues API URL:', searchUrl.toString());
      const response = await fetch(searchUrl.toString());
      if (!response.ok) {
        const errorText = await response.text();
        console.error('JamBase Venues API Error Response:', errorText);
        throw new Error(`JamBase API error: ${response.status} ${response.statusText} - ${errorText}`);
      }
      const data = await response.json();
      console.log('JamBase Venues API Response:', data);
      return data.venues || [];
    } catch (error) {
      console.error('JamBase Venues API Error:', error);
      throw new Error(`Failed to search JamBase venues: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Get user's events
  async getUserEvents(userId: string): Promise<{ events: Event[] }> {
    const { data, error } = await supabase
      .from('user_jambase_events')
      .select(`
        jambase_event_id,
        jambase_events (*)
      `)
      .eq('user_id', userId);

    if (error) {
      throw new Error(`Failed to fetch user events: ${error.message}`);
    }

    const events = data?.map(ue => ue.jambase_events).filter(Boolean) || [];
    return { events };
  }

  // Convert Event to Concert format for backward compatibility
  private eventToConcert(event: Event): Concert {
    return {
      id: event.id.toString(),
      artist: event.artist_name || event.event_name.split(' at ')[0] || 'Unknown Artist',
      date: event.event_date,
      venue: event.venue_name || event.location,
      profile_pic: undefined,
      tour: event.tour_name,
      setlist: Array.isArray(event.setlist) ? event.setlist : [],
      venue_location: event.venue_city && event.venue_state 
        ? `${event.venue_city}, ${event.venue_state}` 
        : event.location,
      source: event.jambase_event_id ? 'jambase_api' : 'manual',
      confidence: event.jambase_event_id ? 'high' : 'medium',
      created_at: event.created_at || new Date().toISOString()
    };
  }

  // Get user events in Concert format for existing components
  async getUserConcerts(userId: string): Promise<Concert[]> {
    const result = await this.getUserEvents(userId);
    return result.events.map(event => this.eventToConcert(event));
  }

  // Search for most similar events (up to 20) based on structured parameters
  async searchSimilarEvents(params: { artist: string; venue?: string; date?: string }, userId: string): Promise<{ events: Event[]; totalFound: number; searchType: 'similar' }> {
    try {
      // First check Supabase for existing similar events
      let existingEvents: Event[] = [];
      
      if (params.venue && params.date) {
        // Search with all parameters
        const { data } = await supabase
          .from('jambase_events')
          .select('*')
          .ilike('artist_name', `%${params.artist}%`)
          .ilike('venue_name', `%${params.venue}%`)
          .eq('event_date', params.date)
          .limit(20);
        existingEvents = data || [];
      } else if (params.venue) {
        // Search with artist and venue
        const { data } = await supabase
          .from('jambase_events')
          .select('*')
          .ilike('artist_name', `%${params.artist}%`)
          .ilike('venue_name', `%${params.venue}%`)
          .limit(20);
        existingEvents = data || [];
      } else if (params.date) {
        // Search with artist and date
        const { data } = await supabase
          .from('jambase_events')
          .select('*')
          .ilike('artist_name', `%${params.artist}%`)
          .eq('event_date', params.date)
          .limit(20);
        existingEvents = data || [];
      } else {
        // Search with artist only
        const { data } = await supabase
          .from('jambase_events')
          .select('*')
          .ilike('artist_name', `%${params.artist}%`)
          .limit(20);
        existingEvents = data || [];
      }

      // If we have enough existing events, return them
      if (existingEvents.length >= 20) {
        return {
          events: existingEvents.slice(0, 20),
          totalFound: existingEvents.length,
          searchType: 'similar'
        };
      }

      // Search JamBase for additional events
      const jamBaseEvents = await this.searchJamBaseEvents(params, 20 - existingEvents.length);
      
      // Combine and deduplicate events
      const allEvents: Event[] = [...existingEvents];
      const existingJamBaseIds = new Set(existingEvents.map(e => e.jambase_event_id).filter(Boolean));
      
      for (const event of jamBaseEvents) {
        if (event.jambase_event_id && !existingJamBaseIds.has(event.jambase_event_id)) {
          allEvents.push(event as Event);
          existingJamBaseIds.add(event.jambase_event_id);
        }
      }

      // Insert new events to Supabase
      const newEvents = jamBaseEvents.filter(e => e.jambase_event_id && !existingJamBaseIds.has(e.jambase_event_id));
      if (newEvents.length > 0) {
        try {
          const { data: insertedEvents } = await supabase
            .from('jambase_events')
            .insert(newEvents)
            .select();
          
          if (insertedEvents) {
            // Replace new events with inserted ones (to get proper IDs)
            const insertedIds = new Set(insertedEvents.map(e => e.jambase_event_id));
            const updatedAllEvents = allEvents.map(e => {
              if (insertedIds.has(e.jambase_event_id)) {
                return insertedEvents.find(ie => ie.jambase_event_id === e.jambase_event_id) || e;
              }
              return e;
            });
            
            return {
              events: updatedAllEvents.slice(0, 20),
              totalFound: updatedAllEvents.length,
              searchType: 'similar'
            };
          }
        } catch (insertError) {
          console.error('Error inserting new events:', insertError);
        }
      }

      return {
        events: allEvents.slice(0, 20),
        totalFound: allEvents.length,
        searchType: 'similar'
      };
    } catch (error) {
      console.error('Error searching similar events:', error);
      throw new Error(`Failed to search similar events: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Search for artist's recent and upcoming events (10 each)
  async searchArtistEvents(artistName: string, userId: string): Promise<{ events: Event[]; totalFound: number; searchType: 'artist_recent_upcoming' }> {
    try {
      const now = new Date();
      const recentCutoff = new Date(now.getTime() - (365 * 24 * 60 * 60 * 1000)); // 1 year ago
      
      // Get recent events from Supabase (past year)
      const { data: recentEvents } = await supabase
        .from('jambase_events')
        .select('*')
        .ilike('artist_name', `%${artistName}%`)
        .lt('event_date', now.toISOString())
        .gte('event_date', recentCutoff.toISOString())
        .order('event_date', { ascending: false })
        .limit(10);

      // Get upcoming events from Supabase
      const { data: upcomingEvents } = await supabase
        .from('jambase_events')
        .select('*')
        .ilike('artist_name', `%${artistName}%`)
        .gte('event_date', now.toISOString())
        .order('event_date', { ascending: true })
        .limit(10);

      const existingEvents = [...(recentEvents || []), ...(upcomingEvents || [])];
      
      // If we have enough events, return them
      if (existingEvents.length >= 20) {
        return {
          events: existingEvents.slice(0, 20),
          totalFound: existingEvents.length,
          searchType: 'artist_recent_upcoming'
        };
      }

      // Search JamBase for additional events
      const jamBaseEvents = await this.searchJamBaseEvents({ artist: artistName }, 20 - existingEvents.length);
      
      // Combine and deduplicate events
      const allEvents: Event[] = [...existingEvents];
      const existingJamBaseIds = new Set(existingEvents.map(e => e.jambase_event_id).filter(Boolean));
      
      for (const event of jamBaseEvents) {
        if (event.jambase_event_id && !existingJamBaseIds.has(event.jambase_event_id)) {
          allEvents.push(event as Event);
          existingJamBaseIds.add(event.jambase_event_id);
        }
      }

      // Insert new events to Supabase
      const newEvents = jamBaseEvents.filter(e => e.jambase_event_id && !existingJamBaseIds.has(e.jambase_event_id));
      if (newEvents.length > 0) {
        try {
          const { data: insertedEvents } = await supabase
            .from('jambase_events')
            .insert(newEvents)
            .select();
          
          if (insertedEvents) {
            // Replace new events with inserted ones (to get proper IDs)
            const insertedIds = new Set(insertedEvents.map(e => e.jambase_event_id));
            const updatedAllEvents = allEvents.map(e => {
              if (insertedIds.has(e.jambase_event_id)) {
                return insertedEvents.find(ie => ie.jambase_event_id === e.jambase_event_id) || e;
              }
              return e;
            });
            
            return {
              events: updatedAllEvents.slice(0, 20),
              totalFound: updatedAllEvents.length,
              searchType: 'artist_recent_upcoming'
            };
          }
        } catch (insertError) {
          console.error('Error inserting new events:', insertError);
        }
      }

      return {
        events: allEvents.slice(0, 20),
        totalFound: allEvents.length,
        searchType: 'artist_recent_upcoming'
      };
    } catch (error) {
      console.error('Error searching artist events:', error);
      throw new Error(`Failed to search artist events: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Search JamBase for multiple events
  private async searchJamBaseEvents(params: { artist: string; venue?: string; date?: string }, limit: number = 20): Promise<Event[]> {
    const url = new URL(`${JAMBASE_BASE_URL}/events`);
    url.searchParams.append('apikey', JAMBASE_API_KEY);
    url.searchParams.append('num', limit.toString());
    url.searchParams.append('page', '0');
    url.searchParams.append('o', 'json');
    
    if (params.artist) url.searchParams.append('artist', params.artist);
    if (params.venue) url.searchParams.append('venue', params.venue);
    if (params.date) {
      url.searchParams.append('eventDateFrom', params.date);
      url.searchParams.append('eventDateTo', params.date);
    }

    console.log('JamBase API URL:', url.toString());

    try {
      const res = await fetch(url.toString());
      if (!res.ok) {
        const errorText = await res.text();
        console.error('JamBase API Error Response:', errorText);
        console.log('Falling back to mock data due to API error');
        return this.getMockEvents(params, limit);
      }
      
      const json = await res.json();
      console.log('JamBase API Response:', json);
      
      // Handle JSON-LD format response
      let events: any[] = [];
      
      if (Array.isArray(json)) {
        // Direct array of events
        events = json;
      } else if (json['@graph'] && Array.isArray(json['@graph'])) {
        // JSON-LD graph format
        events = json['@graph'];
      } else if (json.events && Array.isArray(json.events)) {
        // Simple events array
        events = json.events;
      } else {
        console.log('Unexpected response format, falling back to mock data');
        return this.getMockEvents(params, limit);
      }

      if (events.length === 0) {
        console.log('No events from API, falling back to mock data');
        return this.getMockEvents(params, limit);
      }

      return events.map((event: any) => {
        // Handle JSON-LD format
        const eventName = event.name || event.title || 'Untitled Event';
        const identifier = event.identifier || event.id || '';
        const startDate = event.startDate || event.dateTime || new Date().toISOString();
        
        // Extract performer information (JSON-LD format)
        let artistName = '';
        let artistId = '';
        let genres: string[] = [];
        
        if (event.performer && Array.isArray(event.performer)) {
          const headliner = event.performer.find((p: any) => p['x-performanceRank'] === 1) || event.performer[0];
          if (headliner) {
            artistName = headliner.name || '';
            artistId = headliner.identifier || '';
            genres = headliner.genre || [];
          }
        } else if (event.artist) {
          artistName = event.artist.name || '';
          artistId = event.artist.id || '';
          genres = event.artist.genres || [];
        }
        
        // Extract venue information
        const venue = event.location || event.venue || {};
        const venueName = venue.name || 'Unknown Venue';
        const venueId = venue.identifier || venue.id || '';
        const venueAddress = venue.address?.streetAddress || '';
        const venueCity = venue.address?.addressLocality || '';
        const venueState = venue.address?.addressRegion?.alternateName || '';
        const venueZip = venue.address?.postalCode || '';
        const latitude = venue.geo?.latitude || null;
        const longitude = venue.geo?.longitude || null;
        
        // Extract offers/ticketing information
        const offers = event.offers || [];
        const primaryOffer = offers.find((o: any) => o.category === 'ticketingLinkPrimary') || offers[0];
        const ticketAvailable = offers.length > 0;
        const ticketUrl = primaryOffer?.url || '';
        
        return {
          id: '', // Will be generated by Supabase
          jambase_event_id: identifier,
          title: eventName,
          artist_name: artistName,
          artist_id: artistId,
          venue_name: venueName,
          venue_id: venueId,
          event_date: startDate,
          doors_time: event.doorTime || null,
          description: event.description || `Live performance by ${artistName}`,
          genres: genres,
          venue_address: venueAddress,
          venue_city: venueCity,
          venue_state: venueState,
          venue_zip: venueZip,
          latitude: latitude,
          longitude: longitude,
          ticket_available: ticketAvailable,
          price_range: primaryOffer?.priceSpecification?.price || null,
          ticket_urls: ticketUrl ? [ticketUrl] : [],
          setlist: null,
          tour_name: null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          // Legacy fields for backward compatibility
          location: venueCity && venueState 
            ? `${venueCity}, ${venueState}`.trim()
            : '',
          event_name: eventName,
          event_time: startDate.split('T')[1] || null,
          url: event.url || ticketUrl || '',
        };
      });
    } catch (error) {
      console.error('JamBase API Error:', error);
      console.log('Falling back to mock data due to fetch error');
      return this.getMockEvents(params, limit);
    }
  }

  // Mock data fallback when JamBase API is unavailable
  private getMockEvents(params: { artist: string; venue?: string; date?: string }, limit: number): Event[] {
    const mockEvents: Event[] = [];
    const now = new Date();
    
    // Generate mock events for the artist
    for (let i = 0; i < Math.min(limit, 10); i++) {
      const eventDate = new Date(now.getTime() + (i * 7 * 24 * 60 * 60 * 1000)); // Every 7 days
      const isPast = Math.random() > 0.5;
      const date = isPast 
        ? new Date(now.getTime() - (i * 7 * 24 * 60 * 60 * 1000))
        : eventDate;

      const venues = [
        'Madison Square Garden', 'Hollywood Bowl', 'Red Rocks Amphitheatre', 
        'The Greek Theatre', 'Radio City Music Hall', 'The Fillmore',
        'House of Blues', 'The Roxy', 'Webster Hall', 'Bowery Ballroom'
      ];
      
      const cities = ['New York', 'Los Angeles', 'Denver', 'Chicago', 'Austin', 'Nashville', 'Seattle', 'Boston'];
      const states = ['NY', 'CA', 'CO', 'IL', 'TX', 'TN', 'WA', 'MA'];

      const venueIndex = Math.floor(Math.random() * venues.length);
      const cityIndex = Math.floor(Math.random() * cities.length);
      
      const event: Event = {
        id: `mock-${i}`,
        jambase_event_id: `mock-jb-${i}`,
        title: `${params.artist} Concert`,
        artist_name: params.artist,
        artist_id: `artist-${i}`,
        venue_name: params.venue || venues[venueIndex],
        venue_id: `venue-${i}`,
        event_date: date.toISOString(),
        doors_time: new Date(date.getTime() - (60 * 60 * 1000)).toISOString(), // 1 hour before
        description: `Live performance by ${params.artist}`,
        genres: ['Rock', 'Pop', 'Alternative'],
        venue_address: `${Math.floor(Math.random() * 9999) + 1} Main St`,
        venue_city: cities[cityIndex],
        venue_state: states[cityIndex],
        venue_zip: `${Math.floor(Math.random() * 90000) + 10000}`,
        latitude: 40.7128 + (Math.random() - 0.5) * 10,
        longitude: -74.0060 + (Math.random() - 0.5) * 10,
        ticket_available: Math.random() > 0.3,
        price_range: `$${Math.floor(Math.random() * 100) + 25}-$${Math.floor(Math.random() * 200) + 100}`,
        ticket_urls: ['https://ticketmaster.com/mock'],
        setlist: null,
        tour_name: `${params.artist} Tour ${new Date().getFullYear()}`,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        location: `${cities[cityIndex]}, ${states[cityIndex]}`,
        event_name: `${params.artist} Concert`,
        event_time: date.toTimeString().split(' ')[0],
        url: 'https://jambase.com/mock'
      };
      
      mockEvents.push(event);
    }
    
    console.log(`Generated ${mockEvents.length} mock events for ${params.artist}`);
    return mockEvents;
  }
}

export const concertSearchService = new ConcertSearchService();
